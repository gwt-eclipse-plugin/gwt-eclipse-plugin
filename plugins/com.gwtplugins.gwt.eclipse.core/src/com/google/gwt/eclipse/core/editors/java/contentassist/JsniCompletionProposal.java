/*******************************************************************************
 * Copyright 2011 Google Inc. All Rights Reserved.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/
package com.google.gwt.eclipse.core.editors.java.contentassist;

import com.google.gdt.eclipse.core.StringUtilities;
import com.google.gwt.eclipse.core.GWTPluginLog;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jdt.core.CompletionProposal;
import org.eclipse.jdt.core.Flags;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.Signature;
import org.eclipse.jdt.ui.text.java.IJavaCompletionProposal;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.IInformationControlCreator;
import org.eclipse.jface.text.contentassist.ICompletionProposalExtension3;
import org.eclipse.jface.text.contentassist.IContextInformation;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.graphics.Point;

/**
 * Wraps a completion proposal generated by the JDT and tweaks it as necessary
 * to make it work for JSNI references).
 */
class JsniCompletionProposal
    extends
    com.google.gwt.eclipse.platform.editors.java.contentassist.JsniCompletionProposal {

  /**
   * Return proposals only for references to a package, type, field, method or
   * constructor (and nothing else).
   */
  public static IJavaCompletionProposal create(
      IJavaCompletionProposal jdtProposal, CompletionProposal wrappedProposal,
      IJavaProject javaProject, int replaceOffset, int replaceLength) {
    switch (wrappedProposal.getKind()) {
      case CompletionProposal.PACKAGE_REF:
      case CompletionProposal.TYPE_REF:
      case CompletionProposal.FIELD_REF:
      case CompletionProposal.METHOD_REF:
        return new JsniCompletionProposal(jdtProposal, wrappedProposal,
            javaProject, replaceOffset, replaceLength);
      default:
        return null;
    }
  }

  private static String getParamTypesSignature(CompletionProposal proposal) {
    String[] paramTypes = Signature.getParameterTypes(new String(
        proposal.getSignature()));

    // JSNI refs must use /'s to separate qualifier segments
    return StringUtilities.join(paramTypes, "").replace('.', '/');
  }

  private final IJavaProject javaProject;

  private int replaceLength;

  private int replaceOffset;

  private String replaceString;

  private JsniCompletionProposal(IJavaCompletionProposal jdtProposal,
      CompletionProposal wrappedProposal, IJavaProject javaProject,
      int replaceOffset, int replaceLength) {
    super(jdtProposal, wrappedProposal);
    this.javaProject = javaProject;
    this.replaceOffset = replaceOffset;
    this.replaceLength = replaceLength;
  }

  public void apply(IDocument document) {
    try {
      document.replace(replaceOffset, replaceLength, getReplaceString());
    } catch (BadLocationException x) {
      // Ignore, as the JDT does
    }
  }

  public String getAdditionalProposalInfo() {
    return jdtProposal.getAdditionalProposalInfo();
  }

  public Object getAdditionalProposalInfo(IProgressMonitor monitor) {
    return getAdditionalProposalInfo();
  }

  public IContextInformation getContextInformation() {
    return jdtProposal.getContextInformation();
  }

  public String getDisplayString() {
    String displayString = jdtProposal.getDisplayString();

    if (wrappedProposal.isConstructor()) {
      // For ctor references, we want to display the "new" method used by JSNI
      displayString = fixCtorDisplayString(displayString);
    }

    return displayString;
  }

  public Image getImage() {
    return jdtProposal.getImage();
  }

  public IInformationControlCreator getInformationControlCreator() {
    return ((ICompletionProposalExtension3) jdtProposal).getInformationControlCreator();
  }

  public int getPrefixCompletionStart(IDocument document, int completionOffset) {
    return 0; // Not used
  }

  public CharSequence getPrefixCompletionText(IDocument document,
      int completionOffset) {
    return null; // Not used
  }

  public int getRelevance() {
    return jdtProposal.getRelevance();
  }

  public Point getSelection(IDocument document) {
    // Selection is always at the end of the completion text
    return new Point(replaceOffset + getReplaceString().length(), 0);
  }

  private String computeCtorCompletion() {
    StringBuilder sb = new StringBuilder();
    sb.append(JSNI_CTOR_METHOD);
    sb.append('(');

    try {
      // References to constructors of non-static inner classes must take an
      // instance of their enclosing class as the first parameter.
      String qualifiedTypeName = Signature.toString(new String(
          wrappedProposal.getDeclarationSignature()));
      IType type = javaProject.findType(qualifiedTypeName);
      if (type != null) {
        // See if the type is a non-static inner class
        IJavaElement typeParent = type.getParent();
        if (typeParent.getElementType() == IJavaElement.TYPE
            && !Flags.isStatic(type.getFlags())) {
          // Calculate the (binary) type signature of the enclosing type
          String outerTypeName = ((IType) typeParent).getFullyQualifiedName();
          String outerTypeSig = Signature.createTypeSignature(outerTypeName,
              true).replace('.', '/');

          // Add as first parameter of ctor references
          sb.append(outerTypeSig);
        }
      }
    } catch (JavaModelException e) {
      GWTPluginLog.logError(e);
    }

    sb.append(getParamTypesSignature(wrappedProposal));
    sb.append(')');
    return sb.toString();
  }

  private String computeFieldCompletion() {
    // No conversion necessary
    return new String(wrappedProposal.getCompletion());
  }

  private String computeMethodCompletion() {
    // Completion is the method name plus the parameter types signature
    StringBuilder sb = new StringBuilder();
    sb.append(wrappedProposal.getName());
    sb.append('(');
    sb.append(getParamTypesSignature(wrappedProposal));
    sb.append(')');
    return sb.toString();
  }

  private String computePackageCompletion() {
    // No conversion necessary
    return new String(wrappedProposal.getCompletion());
  }

  private String computeTypeCompletion() {
    // Completion is the fully-qualified name of the type
    return Signature.toString(new String(wrappedProposal.getSignature()));
  }

  private String createReplaceString() {
    switch (wrappedProposal.getKind()) {
      case CompletionProposal.PACKAGE_REF:
        return computePackageCompletion();
      case CompletionProposal.TYPE_REF:
        return computeTypeCompletion();
      case CompletionProposal.FIELD_REF:
        return computeFieldCompletion();
      case CompletionProposal.METHOD_REF:
        if (wrappedProposal.isConstructor()) {
          return computeCtorCompletion();
        } else {
          return computeMethodCompletion();
        }
      default:
        return "";
    }
  }

  private String getReplaceString() {
    if (replaceString == null) {
      // Lazily construct the replacement string. This is useful especially
      // for constructor completions, since we have to do type lookups.
      replaceString = createReplaceString();
    }
    return replaceString;
  }

}